# set - тип множества - содержит только уникальные элементы

my_set = set()
print(my_set)
print(type(my_set))         # возвращает список типа <class 'set'>

#

my_set.add(1) # добавим элемент 1 в set
print(my_set) # текущее состояние множества говорит о том, что в нем есть один элемент {1} и это 1(единица)

my_set.add(2) # добавим элемент 2 в set
print(my_set) # текущее состояние множества говорит о том, что в нем есть два элемента {1, 2}

# если мы в это множество добавим еще одну 2

my_set.add(2) # добавим элемент 2 в set
print(my_set) # текущее состояние множества говорит о том, что в нем есть два элемента {1, 2}

# ничего не измениться, эта 2 не будет добавлена в это множество, 
# если добавляется такой же элемент который уже есть в этом множестве, то он не будет добавлен в него
# множества работают только с уникальными элементами
# дублицированных элементов во множестве быть не может

# Пример - создадим список

my_list = [1,1,1,1,1,2,2,2,2,3,3,3,4] 
s = set(my_list)                            # создадим множество "s" передавая в него конструктор my_list
print(s)                                    # выведем на экран состояние множества

#  {1, 2, 3, 4} - все дублицированные элементы будут исключены из множества, остаются только уникальные элементы в единственном экземпляре

print(len(s))                               # если мы проверим длину то увидим что он состоит из 4 элементов

# для проверки вхождения того или иного элемента во множестве используется ключевое слово "in" - она возвращает boolean истина или ложь

# print(1 in s)           # True, т.к. действительно 1 содержится во множестве
# print(5 in s)           # False, т.к. 5 отсутствует во множестве

#  Пример

set1 = {1,2,3,4}
set2 = {1,2,3,4,5}

# В данном случает множество set1 является под множеством множества set2, т.к. множество set2 полностью включает в себя множество set1 (set2 содержит все элементы, которые содержит set1)

print(set1.issubset(set2))             # True
print(set2.issubset(set1))             # False , т.к. set1 не включает в себя "5"

# а если мы спросим set2 является ли надмножеством set1

print(set2.issuperset(set1))           # True 

# Сравнение

set1 = {1,2,3}
set2 = {4,5,6}
print(set1.isdisjoint(set2))           # True, т.к. действительно ни один из элементов не совпадает 

# Объединение

set1 = {1,2,3,4}
set2 = {1,2,3,4,5}
set3 = set1.union(set2)                 # union - возвращает новое множество
print(set3)                             # {1, 2, 3, 4, 5}

# Все элементы из множества set2 которые не присутствуют во множестве set1 будут туда добавлены и будет возвращено новое множество set3
# таким образом set3 является объединением двух множеств set1 и set2

# Пересечение / # intersection

# так же возвращает новый объект множества и возвращает в нем те элементы которые присутствуют в обоих множествах

set3 = set1.intersection(set2)                
print(set3)                             # {1, 2, 3, 4} - отображает все элементы кроме 5, т.к. они присутствуют в обоих множествах

# Пересечение / # difference

# возвращает те элементы из множества на котор. вызывается метод в котор не присутствуют элементы (берет элементы только из левого множества)

# simmetric difference берет элементы из 2х (обоих) множеств

set1 = {0,1,2,3,4}
set2 = {1,2,3,4,5}
set3 = set1.difference(set2)
set4 = set1.symmetric_difference(set2)
print(set3)                                 # {0} - метод difference - взял только "0" из левого множества set1, т.к. в правом множестве set2 он отсутствует
print(set4)                                 # {0,5} - метод symmetric_difference - взял "0" из set1, т.к. его нет в set2 и "5" из set2, т.к. его нет в set1


# update

set1.update(set2)
print(set1)                                 # {0, 1, 2, 3, 4, 5} - в set1 добавился элемент "5" из set2, которая в нем отсутствовала
                                            # update - по сути тот же union, но он не возвращает новое множество, а обновляет левое множество

# удаление элемента из множества, существует 3 способа / remove, discard, pop / они не возвращают новые множества, они модифицируют исходное множество

# 1. remove

set1.remove(1)
print(set1) # {0, 2, 3, 4, 5} - действительно удалило "1" из множества set1

# set1.remove(42) # при попытке удалить не существующее значение из множества, выдаст ошибку KeyError / такой ключ во множестве - найден не был

# 2. discard

set1.discard(2)
print(set1) # {0, 3, 4, 5} - действительно удалило "2" из множества set1

set1.discard(42) # при попытке удалить не существующее значение из множества - никакую ошибку не выводит

# 3. pop - удаляет случайный элемент, а не первый + он возвращает его в качестве результата

popped_out_element = set1.pop()
print(popped_out_element) 

# очистка множества clear

set1.clear()
print(set1) # получили пустое множество










